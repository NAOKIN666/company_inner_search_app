"""
ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€æœ€åˆã®ç”»é¢èª­ã¿è¾¼ã¿æ™‚ã«ã®ã¿å®Ÿè¡Œã•ã‚Œã‚‹åˆæœŸåŒ–å‡¦ç†ãŒè¨˜è¿°ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚
"""

############################################################
# ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿
############################################################
import os
import logging
from logging.handlers import TimedRotatingFileHandler
from uuid import uuid4
import sys
import unicodedata
# from dotenv import load_dotenv
import streamlit as st
from docx import Document
from langchain_community.document_loaders import WebBaseLoader
from langchain.text_splitter import CharacterTextSplitter
from langchain_openai import OpenAIEmbeddings
from langchain_community.vectorstores import Chroma
from chromadb.config import Settings
import constants as ct


st.write("âœ… initialize: ã‚¹ã‚¿ãƒ¼ãƒˆ")
############################################################
# è¨­å®šé–¢é€£
############################################################
# ã€Œ.envã€ãƒ•ã‚¡ã‚¤ãƒ«ã§å®šç¾©ã—ãŸç’°å¢ƒå¤‰æ•°ã®èª­ã¿è¾¼ã¿
# load_dotenv(

############################################################
# é–¢æ•°å®šç¾©
############################################################

def initialize():
    """
    ç”»é¢èª­ã¿è¾¼ã¿æ™‚ã«å®Ÿè¡Œã™ã‚‹åˆæœŸåŒ–å‡¦ç†
    """
    st.write("ğŸ“Œ STEP 1: OpenAI APIã‚­ãƒ¼ã‚’å–å¾—")
    OPENAI_API_KEY = st.secrets["OPENAI_API_KEY"]
    st.write("ğŸ“Œ STEP 2: ãƒ­ã‚°å‡ºåŠ›ç”¨ã«ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ä½œæˆ")
    # ãƒ­ã‚°å‡ºåŠ›ç”¨ã«ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ç”Ÿæˆ
    initialize_session_id()
    st.write("ğŸ“Œ STEP 3: ãƒ­ã‚°å‡ºåŠ›ã®è¨­å®š")
    # ãƒ­ã‚°å‡ºåŠ›ã®è¨­å®š
    initialize_logger()
    st.write("ğŸ“Œ STEP 4: æ¤œç´¢å™¨ã‚’ä½œæˆ")
    # RAGã®Retrieverã‚’ä½œæˆ
    initialize_retriever()
    st.write("ğŸ“Œ STEP 5: åˆæœŸåŒ–ãƒ‡ãƒ¼ã‚¿ã®ç”¨æ„")
    # åˆæœŸåŒ–ãƒ‡ãƒ¼ã‚¿ã®ç”¨æ„
    initialize_session_state()

def initialize_logger():
    """
    ãƒ­ã‚°å‡ºåŠ›ã®è¨­å®š
    """
    # æŒ‡å®šã®ãƒ­ã‚°ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã™ã‚Œã°èª­ã¿è¾¼ã¿ã€å­˜åœ¨ã—ãªã‘ã‚Œã°æ–°è¦ä½œæˆ
    os.makedirs(ct.LOG_DIR_PATH, exist_ok=True)
    
    # å¼•æ•°ã«æŒ‡å®šã—ãŸåå‰ã®ãƒ­ã‚¬ãƒ¼ï¼ˆãƒ­ã‚°ã‚’è¨˜éŒ²ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã‚’å–å¾—
    # å†åº¦åˆ¥ã®ç®‡æ‰€ã§å‘¼ã³å‡ºã—ãŸå ´åˆã€ã™ã§ã«åŒã˜åå‰ã®ãƒ­ã‚¬ãƒ¼ãŒå­˜åœ¨ã—ã¦ã„ã‚Œã°èª­ã¿è¾¼ã‚€
    logger = logging.getLogger(ct.LOGGER_NAME)

    # ã™ã§ã«ãƒ­ã‚¬ãƒ¼ã«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆãƒ­ã‚°ã®å‡ºåŠ›å…ˆã‚’åˆ¶å¾¡ã™ã‚‹ã‚‚ã®ï¼‰ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€åŒã˜ãƒ­ã‚°å‡ºåŠ›ãŒè¤‡æ•°å›è¡Œã‚ã‚Œãªã„ã‚ˆã†å‡¦ç†ã‚’ä¸­æ–­ã™ã‚‹
    if logger.hasHandlers():
        return

    # 1æ—¥å˜ä½ã§ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸­èº«ã‚’ãƒªã‚»ãƒƒãƒˆã—ã€åˆ‡ã‚Šæ›¿ãˆã‚‹è¨­å®š
    log_handler = TimedRotatingFileHandler(
        os.path.join(ct.LOG_DIR_PATH, ct.LOG_FILE),
        when="D",
        encoding="utf8"
    )
    # å‡ºåŠ›ã™ã‚‹ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå®šç¾©
    # - ã€Œlevelnameã€: ãƒ­ã‚°ã®é‡è¦åº¦ï¼ˆINFO, WARNING, ERRORãªã©ï¼‰
    # - ã€Œasctimeã€: ãƒ­ã‚°ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆã„ã¤è¨˜éŒ²ã•ã‚ŒãŸã‹ï¼‰
    # - ã€Œlinenoã€: ãƒ­ã‚°ãŒå‡ºåŠ›ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®è¡Œç•ªå·
    # - ã€ŒfuncNameã€: ãƒ­ã‚°ãŒå‡ºåŠ›ã•ã‚ŒãŸé–¢æ•°å
    # - ã€Œsession_idã€: ã‚»ãƒƒã‚·ãƒ§ãƒ³IDï¼ˆèª°ã®ã‚¢ãƒ—ãƒªæ“ä½œã‹åˆ†ã‹ã‚‹ã‚ˆã†ã«ï¼‰
    # - ã€Œmessageã€: ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    formatter = logging.Formatter(
        f"[%(levelname)s] %(asctime)s line %(lineno)s, in %(funcName)s, session_id={st.session_state.session_id}: %(message)s"
    )

    # å®šç¾©ã—ãŸãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ã®é©ç”¨
    log_handler.setFormatter(formatter)

    # ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’ã€ŒINFOã€ã«è¨­å®š
    logger.setLevel(logging.INFO)

    # ä½œæˆã—ãŸãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆãƒ­ã‚°å‡ºåŠ›å…ˆã‚’åˆ¶å¾¡ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã‚’ã€
    # ãƒ­ã‚¬ãƒ¼ï¼ˆãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å®Ÿéš›ã«ç”Ÿæˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã«è¿½åŠ ã—ã¦ãƒ­ã‚°å‡ºåŠ›ã®æœ€çµ‚è¨­å®š
    logger.addHandler(log_handler)


def initialize_session_id():
    """
    ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã®ä½œæˆ
    """
    if "session_id" not in st.session_state:
        # ãƒ©ãƒ³ãƒ€ãƒ ãªæ–‡å­—åˆ—ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³IDï¼‰ã‚’ã€ãƒ­ã‚°å‡ºåŠ›ç”¨ã«ä½œæˆ
        st.session_state.session_id = uuid4().hex


def initialize_retriever():
    """
    ç”»é¢èª­ã¿è¾¼ã¿æ™‚ã«RAGã®Retrieverï¼ˆãƒ™ã‚¯ã‚¿ãƒ¼ã‚¹ãƒˆã‚¢ã‹ã‚‰æ¤œç´¢ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã‚’ä½œæˆ
    """
    st.write("ğŸ“Œ STEP 4-1: ãƒ­ã‚¬ãƒ¼ã®èª­ã¿è¾¼ã¿")
    # ãƒ­ã‚¬ãƒ¼ã‚’èª­ã¿è¾¼ã‚€ã“ã¨ã§ã€å¾Œç¶šã®å‡¦ç†ä¸­ã«ç™ºç”Ÿã—ãŸã‚¨ãƒ©ãƒ¼ãªã©ãŒãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜éŒ²ã•ã‚Œã‚‹
    logger = logging.getLogger(ct.LOGGER_NAME)

    st.write("ğŸ“Œ STEP 4-2: æ¤œç´¢å™¨ã‚ã‚Œã°å‡¦ç†æŠœã‘ã‚‹")
    # ã™ã§ã«RetrieverãŒä½œæˆæ¸ˆã¿ã®å ´åˆã€å¾Œç¶šã®å‡¦ç†ã‚’ä¸­æ–­
    if "retriever" in st.session_state:
        return

    st.write("ğŸ“Œ STEP 4-3: RAGã®å‚ç…§å…ˆã¨ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿")
    # RAGã®å‚ç…§å…ˆã¨ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿
    docs_all = load_data_sources()

    st.write("ğŸ“Œ STEP 4-4: OSãŒWindowsã®å ´åˆã€Unicodeæ­£è¦åŒ–ã¨ã€cp932ï¼ˆWindowsç”¨ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰ï¼‰ã§è¡¨ç¾ã§ããªã„æ–‡å­—ã‚’é™¤å»")
    # OSãŒWindowsã®å ´åˆã€Unicodeæ­£è¦åŒ–ã¨ã€cp932ï¼ˆWindowsç”¨ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰ï¼‰ã§è¡¨ç¾ã§ããªã„æ–‡å­—ã‚’é™¤å»
    for doc in docs_all:
        doc.page_content = adjust_string(doc.page_content)
        for key in doc.metadata:
            doc.metadata[key] = adjust_string(doc.metadata[key])

    st.write("ğŸ“Œ STEP 4-5: åŸ‹ã‚è¾¼ã¿ãƒ¢ãƒ‡ãƒ«ã®ç”¨æ„")
    # åŸ‹ã‚è¾¼ã¿ãƒ¢ãƒ‡ãƒ«ã®ç”¨æ„
    try:
        embeddings = OpenAIEmbeddings()
        st.write("âœ… OpenAIEmbeddings æ­£å¸¸ã«ç”Ÿæˆã•ã‚Œã¾ã—ãŸ")
    except Exception as e:
        st.error("âŒ OpenAIEmbeddings ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ")
        st.error(str(e))
        st.stop()

    # CSVç”±æ¥ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ã€ãã‚Œä»¥å¤–ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’åˆ†é¡ã™ã‚‹tç›®ã«ç©ºãƒªã‚¹ãƒˆã‚’ç”¨æ„
    csv_docs = []
    other_docs = []

    st.write("ğŸ“Œ STEP 4-6: docs_all ã®ä¸­èº«ã‚’ï¼‘ã¤ãšã¤ãƒã‚§ãƒƒã‚¯ã—ã¦åˆ†é¡ã™ã‚‹")
    # docs_all ã®ä¸­èº«ã‚’ï¼‘ã¤ãšã¤ãƒã‚§ãƒƒã‚¯ã—ã¦åˆ†é¡ã™ã‚‹
    for doc in docs_all:
        # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã«å«ã¾ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®æ‹¡å¼µå­ã§åˆ¤å®š
        if doc.metadata['source'].endswith('.csv'):
            csv_docs.append(doc)
        else:
            other_docs.append(doc)

    # ãƒãƒ£ãƒ³ã‚¯åˆ†å‰²ç”¨ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
    text_splitter = CharacterTextSplitter(
        # ãƒ¬ãƒ™ãƒ«ã€Œæ˜“ã€å•é¡Œï¼’
        chunk_size=ct.CHUNK_SIZE,
        chunk_overlap=ct.CHUNK_OVERLAP,
        separator="\n"
    )

    st.write("ğŸ“Œ STEP 4-7: ãƒãƒ£ãƒ³ã‚¯åˆ†å‰²ã‚’å®Ÿæ–½(CSVä»¥å¤–ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ)")
    # ãƒãƒ£ãƒ³ã‚¯åˆ†å‰²ã‚’å®Ÿæ–½(CSVä»¥å¤–ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ)
    splitted_other_docs = text_splitter.split_documents(other_docs)


    # åˆ†å‰²æ¸ˆã¿ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ã€ç„¡åŠ å·¥ã®CSVãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’çµåˆã—ã¦æœ€çµ‚ç‰ˆã¨ã™ã‚‹
    final_docs = splitted_other_docs + csv_docs

    st.write(f"âœ… final_docs ã®ä»¶æ•°: {len(final_docs)}")
    st.write("ğŸ“Œ STEP 4-8: ãƒ™ã‚¯ã‚¿ãƒ¼ã‚¹ãƒˆã‚¢ã®ä½œæˆ")
    # ãƒ™ã‚¯ã‚¿ãƒ¼ã‚¹ãƒˆã‚¢ã®ä½œæˆ
    try:
        db = Chroma.from_documents(
            final_docs,
            embedding=embeddings,
            client_settings=Settings(anonymized_telemetry=False)
        )
        st.write("âœ… Chroma.from_documents å®Ÿè¡ŒæˆåŠŸ")
    except Exception as e:
        st.error("âŒ ãƒ™ã‚¯ã‚¿ãƒ¼ã‚¹ãƒˆã‚¢ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ")
        st.error(str(e))  # â† ã‚¨ãƒ©ãƒ¼è©³ç´°ã‚’è¡¨ç¤º
        st.stop()

    st.write("ğŸ“Œ STEP 4-9: ãƒ™ã‚¯ã‚¿ãƒ¼ã‚¹ãƒˆã‚¢ã‚’æ¤œç´¢ã™ã‚‹Retrieverã®ä½œæˆ")
    # ãƒ™ã‚¯ã‚¿ãƒ¼ã‚¹ãƒˆã‚¢ã‚’æ¤œç´¢ã™ã‚‹Retrieverã®ä½œæˆ
    st.session_state.rag_retriever = db.as_retriever(search_type="mmr", search_kwargs={"k": ct.TOP_K, "lambda_mult": ct.LAMBDA_MULT})


def initialize_session_state():
    """
    åˆæœŸåŒ–ãƒ‡ãƒ¼ã‚¿ã®ç”¨æ„
    """
    if "messages" not in st.session_state:
        # ã€Œè¡¨ç¤ºç”¨ã€ã®ä¼šè©±ãƒ­ã‚°ã‚’é †æ¬¡æ ¼ç´ã™ã‚‹ãƒªã‚¹ãƒˆã‚’ç”¨æ„
        st.session_state.messages = []
        # ã€ŒLLMã¨ã®ã‚„ã‚Šã¨ã‚Šç”¨ã€ã®ä¼šè©±ãƒ­ã‚°ã‚’é †æ¬¡æ ¼ç´ã™ã‚‹ãƒªã‚¹ãƒˆã‚’ç”¨æ„
        st.session_state.chat_history = []


def load_data_sources():
    """
    RAGã®å‚ç…§å…ˆã¨ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿

    Returns:
        èª­ã¿è¾¼ã‚“ã é€šå¸¸ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹
    """
    # ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’æ ¼ç´ã™ã‚‹ç”¨ã®ãƒªã‚¹ãƒˆ
    docs_all = []
    # ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã®å®Ÿè¡Œï¼ˆæ¸¡ã—ãŸå„ãƒªã‚¹ãƒˆã«ãƒ‡ãƒ¼ã‚¿ãŒæ ¼ç´ã•ã‚Œã‚‹ï¼‰
    recursive_file_check(ct.RAG_TOP_FOLDER_PATH, docs_all)

    web_docs_all = []
    # ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã¯åˆ¥ã«ã€æŒ‡å®šã®Webãƒšãƒ¼ã‚¸å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚‚èª­ã¿è¾¼ã¿
    # èª­ã¿è¾¼ã¿å¯¾è±¡ã®Webãƒšãƒ¼ã‚¸ä¸€è¦§ã«å¯¾ã—ã¦å‡¦ç†
    for web_url in ct.WEB_URL_LOAD_TARGETS:
        # æŒ‡å®šã®Webãƒšãƒ¼ã‚¸ã‚’èª­ã¿è¾¼ã¿
        loader = WebBaseLoader(web_url)
        web_docs = loader.load()
        # foræ–‡ã®å¤–ã®ãƒªã‚¹ãƒˆã«èª­ã¿è¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’è¿½åŠ 
        web_docs_all.extend(web_docs)
    # é€šå¸¸èª­ã¿è¾¼ã¿ã®ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã«Webãƒšãƒ¼ã‚¸ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
    docs_all.extend(web_docs_all)

    return docs_all


def recursive_file_check(path, docs_all):
    """
    RAGã®å‚ç…§å…ˆã¨ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿

    Args:
        path: èª­ã¿è¾¼ã¿å¯¾è±¡ã®ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ•ã‚©ãƒ«ãƒ€ã®ãƒ‘ã‚¹
        docs_all: ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’æ ¼ç´ã™ã‚‹ç”¨ã®ãƒªã‚¹ãƒˆ
    """
    # ãƒ‘ã‚¹ãŒãƒ•ã‚©ãƒ«ãƒ€ã‹ã©ã†ã‹ã‚’ç¢ºèª
    if os.path.isdir(path):
        # ãƒ•ã‚©ãƒ«ãƒ€ã®å ´åˆã€ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ•ã‚©ãƒ«ãƒ€åã®ä¸€è¦§ã‚’å–å¾—
        files = os.listdir(path)
        # å„ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ•ã‚©ãƒ«ãƒ€ã«å¯¾ã—ã¦å‡¦ç†
        for file in files:
            # ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ•ã‚©ãƒ«ãƒ€åã ã‘ã§ãªãã€ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—
            full_path = os.path.join(path, file)
            # ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’æ¸¡ã—ã€å†å¸°çš„ã«ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã®é–¢æ•°ã‚’å®Ÿè¡Œ
            recursive_file_check(full_path, docs_all)
    else:
        # ãƒ‘ã‚¹ãŒãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
        file_load(path, docs_all)


def file_load(path, docs_all):
    """
    ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿

    Args:
        path: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        docs_all: ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’æ ¼ç´ã™ã‚‹ç”¨ã®ãƒªã‚¹ãƒˆ
    """
    # ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã‚’å–å¾—
    file_extension = os.path.splitext(path)[1]
    # ãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆæ‹¡å¼µå­ã‚’å«ã‚€ï¼‰ã‚’å–å¾—
    file_name = os.path.basename(path)

    # æƒ³å®šã—ã¦ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®å ´åˆã®ã¿èª­ã¿è¾¼ã‚€
    if file_extension in ct.SUPPORTED_EXTENSIONS:
        # ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã«åˆã£ãŸdata loaderã‚’ä½¿ã£ã¦ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
        loader = ct.SUPPORTED_EXTENSIONS[file_extension](path)
        docs = loader.load()
        docs_all.extend(docs)


def adjust_string(s):
    """
    Windowsç’°å¢ƒã§RAGãŒæ­£å¸¸å‹•ä½œã™ã‚‹ã‚ˆã†èª¿æ•´
    
    Args:
        s: èª¿æ•´ã‚’è¡Œã†æ–‡å­—åˆ—
    
    Returns:
        èª¿æ•´ã‚’è¡Œã£ãŸæ–‡å­—åˆ—
    """
    # èª¿æ•´å¯¾è±¡ã¯æ–‡å­—åˆ—ã®ã¿
    if type(s) is not str:
        return s

    # OSãŒWindowsã®å ´åˆã€Unicodeæ­£è¦åŒ–ã¨ã€cp932ï¼ˆWindowsç”¨ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰ï¼‰ã§è¡¨ç¾ã§ããªã„æ–‡å­—ã‚’é™¤å»
    if sys.platform.startswith("win"):
        s = unicodedata.normalize('NFC', s)
        s = s.encode("cp932", "ignore").decode("cp932")
        return s
    
    # OSãŒWindowsä»¥å¤–ã®å ´åˆã¯ãã®ã¾ã¾è¿”ã™
    return s